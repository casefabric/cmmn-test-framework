'use strict';

import Definitions from '../../../cmmn/definitions/definitions';
import CaseTeam from '../../../cmmn/team/caseteam';
import CaseTeamUser, { CaseOwner } from "../../../cmmn/team/caseteamuser";
import CaseService from '../../../service/case/caseservice';
import DebugService from '../../../service/case/debugservice';
import StartCase from '../../../service/case/startcase';
import CaseEngineResponse from '../../../service/response';
import TenantService from '../../../service/tenant/tenantservice';
import TestCase from '../../../test/testcase';
import { SomeTime } from '../../../test/time';
import Util from '../../../test/util';
import WorldWideTestTenant from '../../setup/worldwidetesttenant';

const definition = Definitions.CaseTeam;
const tenant = Util.generateId();
const worldwideTenant = new WorldWideTestTenant(tenant);
const user = worldwideTenant.sender;

export default class TestInvalidStartCase extends TestCase {
    async onPrepareTest() {
        await worldwideTenant.create();
        await definition.deploy(user, tenant);
    }

    startCase: StartCase = { tenant, definition, debug: true };

    async run() {

        const startCase = this.startCase;

        // Case team without owner
        startCase.caseTeam = new CaseTeam([new CaseTeamUser(user)]);
        await this.tryStartCase("Missing owner should fail");

        // Case team with invalid roles
        startCase.caseTeam = new CaseTeam([new CaseOwner(user, ["ADMIN", "Not-Exisitng-CaseRole-Not-Allowed-In-Team"])]);
        await this.tryStartCase("Invalid roles should fail");

        // TODO: add a check for invalid member type in the backend??
        // Case team with invalid member type
        // startCase.caseTeam = new CaseTeam([new CaseOwner(sender, [], 'wrong-type')]);
        // await this.tryStartCase("Wrong member type should fail");

        // Remove case team, sender would become member and owner of the new case to be started (if that ever succeeds ...)
        delete startCase.caseTeam;

        // Invalid format of case instance id
        startCase.caseInstanceId = 'UeÃ¨';
        await this.tryStartCase(`Invalid case instance id '${startCase.caseInstanceId}' should fail`);

        // Using tenant id as case instance id should fail. tenant is 'World-Wide-Test-Tenant'
        startCase.caseInstanceId = tenant;
        await this.tryStartCase(`Using tenant id as case instance id '${startCase.caseInstanceId}' should fail`);

        // Force tenant recovery and then try again, again it should fail. This validates the recovery in combination first command in different type of model actor
        await DebugService.forceRecovery(user, tenant);
        await SomeTime(1000, 'Waiting for the tenant to go out-of-memory');
        await this.tryStartCase(`Using tenant id as case instance id '${startCase.caseInstanceId}' should fail`);

        // Since it is an actual tenant, we should be able to retrieve the owners.
        //  Note: this testcase reproduces https://github.com/casefabric/case-engine/issues/308
        await TenantService.getTenantOwners(user, tenant);

        // Remove invalid case instance id and let it be generated by server
        delete startCase.caseInstanceId;

        // Wrong tenant should fail
        startCase.tenant = 'not-existing-tenants';
        await this.tryStartCase(`Wrong tenant should fail with 404`, 404);

        startCase.tenant = tenant;

        // Wrong input should fail
        startCase.inputs = { 'not-existing-input-parameter': 123 };
        await this.tryStartCase(`Wrong inputs should fail`);

        // Remove definition should make it fail
        delete startCase.definition;
        await this.tryStartCase(`Missing case definition should fail`);
    }

    async tryStartCase(msg: string, expectedResponseCode: number = 400) {
        console.log('\n============\n' + msg);
        const response = await CaseService.startCase(user, this.startCase, expectedResponseCode, msg)
        if (response instanceof CaseEngineResponse) {
            await response.text().then(response => console.log("Response text: " + response));
        }
    }
}
